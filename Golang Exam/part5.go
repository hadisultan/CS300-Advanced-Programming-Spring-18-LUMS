package main

import (
	"os"
	"fmt"
    "reflect"
	"encoding/binary"
)

func lookup(codes []int, palette [][3]uint8) []uint8 {
    //fmt.Println("WARNING: Please copy sequential lookup code from Part1 here")
    codesize := len(codes)
    td := make([]uint8,(len(codes)*3))
    for i := 0; i < codesize; i++ {
        temparr := palette[codes[i]]
        td[(i*3)+2] = temparr[0]
        td[(i*3)+1] = temparr[1]        
        td[(i*3)] = temparr[2]
    }
    return td
}

func decompress(codes []int, dict [][]int) []int {
    // fmt.Println("WARNING: Please copy sequential decompress code from Part3 here")
	dictlen := 0
    for i:= 0; i<len(dict); i++ {
        dictlen = dictlen + len(dict[i])
    }
    td := make([]int,dictlen)
    codesize := len(codes)
    pointer := 0
    for i := 0; i < codesize; i++ {
        temparr := dict[codes[i]]
        varlen := len(temparr)
        for j := 0; j < varlen; j++ {
            td[pointer] = temparr[j]
            pointer = pointer + 1
        }
    }
    
    return td
}

/* Part 5: Generate the GIF dictionary
In this part, you are given a list of GIF codes (just like parts 3/4) and you will produce the GIF dictionary which was gien to you in parts 3/4. Dictionary generation is very simple. Initially the dictionary contains 258 entries. Entries 0-255 contain a 1-color array containing the corresponding color code e.g. an array containing just 0 at index 0, an array containing just 1 at index 1 and so on. The next two entries contain empty arrays. 

After that, for each of the GIF codes (EXCLUDING the first two), you will create a new dictionary entry containing ALL colors from the dictionary entry of the PREVIOUS code followed by ONE new color code:
 -> If the CURRENT GIF code is IN the dictionary, use the first element of its dictionary entry
 -> If the CURRENT GIF code is NOT in the dictionary, use the first element of the dictionary entry of the PREVIOUS code

As an example, you can see the dictionary given in the parts 3/4 generated for the corresponding GIF codes.
*/
// var part3_gif_codes = []int{
// 256, 251, 258, 259, 260, 261, 251, 200, 67, 26, 67, 34, 258, 199, 28, 258,
// 249, 68, 167, 261, 242, 125, 251, 243, 124, 111, 209, 249, 118, 152, 275, 259,
// 250, 111, 251, 250, 159, 208, 290, 258, 200, 287, 258, 277, 263, 119, 250, 117,
// 209, 258, 194, 298, 289, 305, 151, 68, 67, 68, 268, 251, 158, 298, 300, 288,
// 290, 250, 313, 67, 77, 262, 326, 260}

func dictionary(codes []int) [][]int {
    var td [][] int
    td = make([][]int,256)
    for i:= 0; i< 256; i++ {
        td[i] = make([]int, 1)
        td[i][0] = i
    }

    td = append(td, []int{})
    td = append(td, []int{})
    pointer := 258
    codesize := len(codes)
    for i:=2; i<codesize; i++ {
        code := codes[i]
        prev := codes[i-1]
        prevdict := td[prev]
        if(code>=len(td)){
            prevdict = append(prevdict, prevdict[0])
        } else {
            prevdict = append(prevdict, td[code][0])
        }
        td = append(td, []int{})
        td[pointer] = prevdict
        pointer = pointer + 1
    }

    // fmt.Println(td)

    return td
}

/* Part 6: Parallel Dictionary generation
You are to only divide the work in just two halves in this part (not recursively). We will also set the maximum dictionary size to exactly 4096 entries. The problem in this part is that dictionary entries on the right may depend on dictionary entries on the left that have not yet been written. Our solution is to make the dictionary an array of channels. You will start 4096 goroutines running the 'once' function (given below) for each channel in the dictionary. You can see that this goroutine will block anyone reading from the channel until a value is written and then it will indefinitely respond to readers. Now the goroutine handling the right half of the GIF codes can easily start its working as any value not available will block it until it becomes available. Make helper functions or lambda functions as the actual goroutines for the left and right halves.

Once you finish the task, see "out5.bmp" generated by the given main function which has the password for Part 7 
*/
func once(val [2]chan []int) {
    value := <-val[0]
    // fmt.Println(value)
    for {
        val[1]<- value
    }
}

func parallel_dictionary(codes []int) [][2]chan []int {
    dict := make([][2]chan[]int, 4096)

    // for i:= 0; i< 4096; i++ {
    //     var a [2]chan[]int
    //     dict[i] = a
    // }

    for i := 0; i<4096; i++ {
        // dict[i] = make([]chan []int, 2)
        dict[i][0] = make(chan []int)
        dict[i][1] = make(chan []int)
    } 
    for i:= 0; i<256; i++ {
        go once(dict[i])
        a := make([]int, 1)
        a[0] = i
        // fmt.Println(i)
        dict[i][0]<- a
    } 
    go once(dict[256])    
    dict[256][0]<-[]int{}
    go once(dict[257])    
    dict[257][0]<-[]int{}

    pointer := 258
    codesize := len(codes)
    for i:=2; i<codesize; i++ {
        code := codes[i]
        prev := codes[i-1]
        prevdict := <-dict[prev][1]
        if(code>=pointer){
            prevdict = append(prevdict, prevdict[0])
        } else {
            cd := <-dict[code][1]
            prevdict = append(prevdict, cd[0])
        }
        go once(dict[pointer])
        dict[pointer][0]<-prevdict
        pointer = pointer + 1
    }

    return dict
}

func main() {
    part5_gif_dict := dictionary(part5_gif_codes)
    bmp("out5.bmp", lookup(decompress(part5_gif_codes, part5_gif_dict), part5_palette), 16, 8)

    part5_gif_parallel_dict := parallel_dictionary(part5_gif_codes)
    // for i := 0 ; i<278; i++ {
    //     value:= <-part5_gif_parallel_dict[i][1]
    //     fmt.Println(value)
    // }
    // fmt.Println("hello")
    for i, x := range part5_gif_dict {
        if !reflect.DeepEqual(x, <-part5_gif_parallel_dict[i][1]) {
            fmt.Println("Parallel dictionary differs from sequential dictionary")
            break
        } else {
        }
    }
    fmt.Println("Done")
}



// DO NOT WORRY ABOUT ANYTHING BELOW THIS LINE

func bmp(filename string, data []uint8, dimX, dimY uint16) {
    bmp, _ := os.Create(filename)
    defer bmp.Close()
    binary.Write(bmp, binary.LittleEndian, []byte{'B','M'})
    binary.Write(bmp, binary.LittleEndian, []int32{int32(54+len(data)), 0, 54, 40, int32(dimX), -1 * int32(dimY), 0x180001, 0, 0, 0, 0, 0, 0})
    binary.Write(bmp, binary.LittleEndian, data)
}

var part5_gif_codes = []int{
256, 251, 258, 259, 260, 261, 260, 250, 196, 262, 236, 203, 259, 249, 265, 243,
265, 261, 242, 268, 258, 188, 182, 147, 270, 250, 188, 209, 282, 188, 188, 276,
251, 270, 289, 196, 287, 251, 236, 265, 194, 288, 264, 251, 244, 187, 273, 275,
294, 288, 272, 289, 154, 236, 197, 251, 200, 311, 267, 259, 282, 147, 244, 265,
193, 203, 250, 187, 146, 195, 288}

var part5_palette = [][3]uint8{
[3]uint8{0,0,0}, [3]uint8{0,0,51}, [3]uint8{0,0,102}, [3]uint8{0,0,153},
[3]uint8{0,0,204}, [3]uint8{0,0,255}, [3]uint8{0,43,0}, [3]uint8{0,43,51},
[3]uint8{0,43,102}, [3]uint8{0,43,153}, [3]uint8{0,43,204}, [3]uint8{0,43,255},
[3]uint8{0,85,0}, [3]uint8{0,85,51}, [3]uint8{0,85,102}, [3]uint8{0,85,153},
[3]uint8{0,85,204}, [3]uint8{0,85,255}, [3]uint8{0,128,0}, [3]uint8{0,128,51},
[3]uint8{0,128,102}, [3]uint8{0,128,153}, [3]uint8{0,128,204}, [3]uint8{0,128,255},
[3]uint8{0,170,0}, [3]uint8{0,170,51}, [3]uint8{0,170,102}, [3]uint8{0,170,153},
[3]uint8{0,170,204}, [3]uint8{0,170,255}, [3]uint8{0,213,0}, [3]uint8{0,213,51},
[3]uint8{0,213,102}, [3]uint8{0,213,153}, [3]uint8{0,213,204}, [3]uint8{0,213,255},
[3]uint8{0,255,0}, [3]uint8{0,255,51}, [3]uint8{0,255,102}, [3]uint8{0,255,153},
[3]uint8{0,255,204}, [3]uint8{0,255,255}, [3]uint8{51,0,0}, [3]uint8{51,0,51},
[3]uint8{51,0,102}, [3]uint8{51,0,153}, [3]uint8{51,0,204}, [3]uint8{51,0,255},
[3]uint8{51,43,0}, [3]uint8{51,43,51}, [3]uint8{51,43,102}, [3]uint8{51,43,153},
[3]uint8{51,43,204}, [3]uint8{51,43,255}, [3]uint8{51,85,0}, [3]uint8{51,85,51},
[3]uint8{51,85,102}, [3]uint8{51,85,153}, [3]uint8{51,85,204}, [3]uint8{51,85,255},
[3]uint8{51,128,0}, [3]uint8{51,128,51}, [3]uint8{51,128,102}, [3]uint8{51,128,153},
[3]uint8{51,128,204}, [3]uint8{51,128,255}, [3]uint8{51,170,0}, [3]uint8{51,170,51},
[3]uint8{51,170,102}, [3]uint8{51,170,153}, [3]uint8{51,170,204}, [3]uint8{51,170,255},
[3]uint8{51,213,0}, [3]uint8{51,213,51}, [3]uint8{51,213,102}, [3]uint8{51,213,153},
[3]uint8{51,213,204}, [3]uint8{51,213,255}, [3]uint8{51,255,0}, [3]uint8{51,255,51},
[3]uint8{51,255,102}, [3]uint8{51,255,153}, [3]uint8{51,255,204}, [3]uint8{51,255,255},
[3]uint8{102,0,0}, [3]uint8{102,0,51}, [3]uint8{102,0,102}, [3]uint8{102,0,153},
[3]uint8{102,0,204}, [3]uint8{102,0,255}, [3]uint8{102,43,0}, [3]uint8{102,43,51},
[3]uint8{102,43,102}, [3]uint8{102,43,153}, [3]uint8{102,43,204}, [3]uint8{102,43,255},
[3]uint8{102,85,0}, [3]uint8{102,85,51}, [3]uint8{102,85,102}, [3]uint8{102,85,153},
[3]uint8{102,85,204}, [3]uint8{102,85,255}, [3]uint8{102,128,0}, [3]uint8{102,128,51},
[3]uint8{102,128,102}, [3]uint8{102,128,153}, [3]uint8{102,128,204}, [3]uint8{102,128,255},
[3]uint8{102,170,0}, [3]uint8{102,170,51}, [3]uint8{102,170,102}, [3]uint8{102,170,153},
[3]uint8{102,170,204}, [3]uint8{102,170,255}, [3]uint8{102,213,0}, [3]uint8{102,213,51},
[3]uint8{102,213,102}, [3]uint8{102,213,153}, [3]uint8{102,213,204}, [3]uint8{102,213,255},
[3]uint8{102,255,0}, [3]uint8{102,255,51}, [3]uint8{102,255,102}, [3]uint8{102,255,153},
[3]uint8{102,255,204}, [3]uint8{102,255,255}, [3]uint8{153,0,0}, [3]uint8{153,0,51},
[3]uint8{153,0,102}, [3]uint8{153,0,153}, [3]uint8{153,0,204}, [3]uint8{153,0,255},
[3]uint8{153,43,0}, [3]uint8{153,43,51}, [3]uint8{153,43,102}, [3]uint8{153,43,153},
[3]uint8{153,43,204}, [3]uint8{153,43,255}, [3]uint8{153,85,0}, [3]uint8{153,85,51},
[3]uint8{153,85,102}, [3]uint8{153,85,153}, [3]uint8{153,85,204}, [3]uint8{153,85,255},
[3]uint8{153,128,0}, [3]uint8{153,128,51}, [3]uint8{153,128,102}, [3]uint8{153,128,153},
[3]uint8{153,128,204}, [3]uint8{153,128,255}, [3]uint8{153,170,0}, [3]uint8{153,170,51},
[3]uint8{153,170,102}, [3]uint8{153,170,153}, [3]uint8{153,170,204}, [3]uint8{153,170,255},
[3]uint8{153,213,0}, [3]uint8{153,213,51}, [3]uint8{153,213,102}, [3]uint8{153,213,153},
[3]uint8{153,213,204}, [3]uint8{153,213,255}, [3]uint8{153,255,0}, [3]uint8{153,255,51},
[3]uint8{153,255,102}, [3]uint8{153,255,153}, [3]uint8{153,255,204}, [3]uint8{153,255,255},
[3]uint8{204,0,0}, [3]uint8{204,0,51}, [3]uint8{204,0,102}, [3]uint8{204,0,153},
[3]uint8{204,0,204}, [3]uint8{204,0,255}, [3]uint8{204,43,0}, [3]uint8{204,43,51},
[3]uint8{204,43,102}, [3]uint8{204,43,153}, [3]uint8{204,43,204}, [3]uint8{204,43,255},
[3]uint8{204,85,0}, [3]uint8{204,85,51}, [3]uint8{204,85,102}, [3]uint8{204,85,153},
[3]uint8{204,85,204}, [3]uint8{204,85,255}, [3]uint8{204,128,0}, [3]uint8{204,128,51},
[3]uint8{204,128,102}, [3]uint8{204,128,153}, [3]uint8{204,128,204}, [3]uint8{204,128,255},
[3]uint8{204,170,0}, [3]uint8{204,170,51}, [3]uint8{204,170,102}, [3]uint8{204,170,153},
[3]uint8{204,170,204}, [3]uint8{204,170,255}, [3]uint8{204,213,0}, [3]uint8{204,213,51},
[3]uint8{204,213,102}, [3]uint8{204,213,153}, [3]uint8{204,213,204}, [3]uint8{204,213,255},
[3]uint8{204,255,0}, [3]uint8{204,255,51}, [3]uint8{204,255,102}, [3]uint8{204,255,153},
[3]uint8{204,255,204}, [3]uint8{204,255,255}, [3]uint8{255,0,0}, [3]uint8{255,0,51},
[3]uint8{255,0,102}, [3]uint8{255,0,153}, [3]uint8{255,0,204}, [3]uint8{255,0,255},
[3]uint8{255,43,0}, [3]uint8{255,43,51}, [3]uint8{255,43,102}, [3]uint8{255,43,153},
[3]uint8{255,43,204}, [3]uint8{255,43,255}, [3]uint8{255,85,0}, [3]uint8{255,85,51},
[3]uint8{255,85,102}, [3]uint8{255,85,153}, [3]uint8{255,85,204}, [3]uint8{255,85,255},
[3]uint8{255,128,0}, [3]uint8{255,128,51}, [3]uint8{255,128,102}, [3]uint8{255,128,153},
[3]uint8{255,128,204}, [3]uint8{255,128,255}, [3]uint8{255,170,0}, [3]uint8{255,170,51},
[3]uint8{255,170,102}, [3]uint8{255,170,153}, [3]uint8{255,170,204}, [3]uint8{255,170,255},
[3]uint8{255,213,0}, [3]uint8{255,213,51}, [3]uint8{255,213,102}, [3]uint8{255,213,153},
[3]uint8{255,213,204}, [3]uint8{255,213,255}, [3]uint8{255,255,0}, [3]uint8{255,255,51},
[3]uint8{255,255,102}, [3]uint8{255,255,153}, [3]uint8{255,255,204}, [3]uint8{255,255,255},
[3]uint8{0,0,0}, [3]uint8{0,0,0}, [3]uint8{0,0,0}, [3]uint8{0,0,0}}
